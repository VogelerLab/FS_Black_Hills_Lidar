#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author: Daniel Rode
# Dependencies:
#   PDAL


"""Generate basic grid metrics using PDAL.

Generate a set of basic, unbuffered gridded point cloud metric rasters for
use in identifying rock artifact hotspots.
"""


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Import libraries
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# Import standard libraries
import sys
import json
import subprocess as sp
from pathlib import Path
from tempfile import TemporaryDirectory

# Import in-house libraries
from vogeler.stdlib import print2
from vogeler.stdlib import init_logger

# Import external libraries
import pdal
import rasterio as rio
from pyproj import Transformer
from pyproj.crs.crs import CRS


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Constants
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

EXE_NAME = sys.argv[0].split('/')[-1]  # This script's filename

# Text printed when user calls this script without proper parameters
HELP_TEXT = f"Usage: {EXE_NAME}  [OPTIONS...]  LAS_PATH  OUT_DIR"

LATLON_EPSG = 4326  # EPSG code for WGS 84
HIGHPASS_DELIM = 1.3716  # 4.5 feet converted to meters
RES = 20  # Grid metrics resolution


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Functions
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def to_latlong(x: float, y: float, crs: CRS) -> (float, float):
    """Convert set of XY coordinates to Longitude Latitude."""

    transformer = Transformer.from_crs(crs, f"EPSG:{LATLON_EPSG}")
    lat, lon = transformer.transform(x, y)

    # Longitude is X (east/west) and latitude is Y (north/south)
    return (lon, lat)


def pdal_get_las_metadata(las_path: Path) -> dict:
    """Use PDAL to read given point cloud metadata and return as dictionary."""

    cmd = (
        'pdal',
        'info',
        '--metadata',
        str(las_path),
    )
    p = sp.run(cmd, check=True, text=True, capture_output=True)

    return json.loads(p.stdout)


def get_pdal_pipeline_json(src_las: Path, dest_dir: Path) -> list:
    """Compile PDAL workflow/pipeline as JSON."""

    src_las = str(src_las)

    # Determine tile bounds
    meta = pdal_get_las_metadata(src_las)
    maxx = meta['metadata']['maxx']
    maxy = meta['metadata']['maxy']
    minx = meta['metadata']['minx']
    miny = meta['metadata']['miny']

    # Ensure that pixel grid aligns with 0,0
    minx = minx // RES * RES
    miny = miny // RES * RES
    maxx = maxx // RES * RES + RES
    maxy = maxy // RES * RES + RES

    # Set raster options and build PDAL pipeline JSON
    rast_options = {
        "type": "writers.gdal",
        "resolution": RES,
        "origin_x": minx,
        "origin_y": miny,
        "height": (maxy - miny) / RES,
        "width": (maxx - minx) / RES,
        # If "binmode" is "true", only points inside the pixel will be
        # considered (no distance-based summary or interpolation will
        # be used)
        "binmode": True,
        # https://pdal.io/en/stable/types.html#types
        "data_type": "float32",
        "gdaldriver": "GTiff",
    }
    pipeline = [
        # Import point cloud
        src_las,
        # Save raster: count of all returns
        {
            **rast_options,
            "dimension": "X",
            "output_type": ["count"],
            "filename": str(dest_dir / "x_all.tif"),
        },
        # Select only first returns
        {
            "type": "filters.expression",
            "expression": "ReturnNumber == 1",
        },
        # Save raster: count, mean intensity, and intensity standard deviation
        # of first returns
        {
            **rast_options,
            "dimension": "Intensity",
            "output_type": ["count", "mean", "stdev"],
            "filename": str(dest_dir / "i_first.tif"),
        },
        # Filter out points below 1.37 meters
        {
            "type": "filters.expression",
            "expression": f"Z >= {HIGHPASS_DELIM}",
        },
        # Save raster: count of first returns above 1.37 meters
        {
            **rast_options,
            "dimension": "X",
            "output_type": ["count"],
            "filename": str(dest_dir / "x_first_hp.tif"),
        },
    ]

    return json.dumps(pipeline)


def get_grid_metrics(src_las: Path) -> list[dict]:
    """Compute grid metrics using PDAL for a given point cloud."""

    all_layers = []
    with TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Format PDAL pipeline JSON
        pipeline_json = get_pdal_pipeline_json(src_las, tmpdir)

        # Run PDAL
        log.info("Running PDAL...")
        p = pdal.Pipeline(pipeline_json)
        try:
            p.execute()
        except RuntimeError as e:
            if str(e) == "writers.gdal: Grid width out of range.":
                log.error(
                    "PDAL was unable to create grid metrics for this tile. "
                    "Tile is likely an oddly shaped edge tile, "
                    "likely over water. "
                    "Missing this tile should not have any consequential "
                    "effect on finding hotspots."
                )
                sys.exit(0)
            else:
                raise e

        # Unstack raster layers (convert each multi-band raster into a set of
        # single-band raster layers, then return all layers so they can be
        # saved as individual single-band rasters)
        log.info("Unstacking outputs...")
        for tmp_tif_path in tmpdir.glob("*.tif"):
            with rio.open(tmp_tif_path, 'r') as f:
                arr = f.read()
                transform = f.transform

                for pixels, band_name in zip(arr, f.descriptions):
                    profile = f.profile
                    _, profile['height'], profile['width'] = arr.shape
                    profile['transform'] = transform

                    all_layers += [{
                        'pixels': pixels,
                        'tif_name': tmp_tif_path.stem,
                        'band_name': band_name,
                        'profile': profile,
                    }]

    return all_layers


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def main() -> None:
    # Parse command line arguments
    pos_args = []
    args = iter(sys.argv[1:])
    for a in args:
        if not a.startswith('-'):
            pos_args += [a] + list(args)
            break
        try:
            match a:
                case _:
                    print2("error: Invalid flag", a)
                    sys.exit(1)
        except StopIteration:
            print2("error: Flag requires value:", a)
            sys.exit(1)
        except ValueError:
            print2("error: Invalid value for flag:", a)
            sys.exit(1)

    try:
        src_las = Path(pos_args[0])
        out_dir = Path(pos_args[1])
    except IndexError:
        print2(HELP_TEXT)
        sys.exit(1)

    # Abort if job was already run
    if out_dir.exists():
        print2(f"Exists (skipping): {out_dir}")
        sys.exit(0)

    # Ensure source file paths exist
    for p in (src_las,):
        if not p.exists():
            print2("error: Path does not exist:", p)
            sys.exit(1)

    # Setup logging
    global log
    log = init_logger()

    # Print start time
    log.info("Starting...")
    log.warning(
        "This script expects that given point clouds are already height"
        " normalized"
    )

    # Ensure export directory exists
    out_dir.mkdir(exist_ok=True, parents=True)

    # Compute LiDAR metrics using PDAL
    rast_layers = get_grid_metrics(src_las)

    # Save rasters to file
    log.info("Writing rasters to files...")
    for layer in rast_layers:
        out_tif_path = (
            out_dir / f"{layer['tif_name']}_{layer['band_name']}.tif"
        )
        profile = layer['profile']
        profile['count'] = 1
        with rio.open(out_tif_path, 'w', **profile) as f:
            f.write(layer['pixels'], 1)

    # Notify process has completed
    log.info("Finished")


if __name__ == '__main__':
    main()
