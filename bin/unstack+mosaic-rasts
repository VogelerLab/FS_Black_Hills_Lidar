#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author: Daniel Rode


"""Unlayer raster tiles and mosaic tiles together.

Some raster products generated by `gridmetrics+chms` are stacked together. For
instance, one of the output rasters may have band 1 as the mean, band 2 as the
max, band 3 as standard deviation, etc... This script unstacks all those bands
so each metric corresponds to just one raster file (that is, the bands of one
raster are unstacked into many rasters). These unstacked rasters are then
stitched together with the corresponding metric from other tiles to create one
raster mosaic for each metric for the whole study area.
"""


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Import libraries
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# Import standard libraries
import os
import sys
import functools
from pathlib import Path
from tempfile import TemporaryDirectory
from concurrent.futures import ProcessPoolExecutor
from concurrent.futures import as_completed as cf_as_completed

from typing import Any
from collections.abc import Callable
from collections.abc import Iterator

# Import in-house libraries
from vogeler.stdlib import print2
from vogeler.stdlib import init_logger

# Import external libraries
import dill
import numpy as np
import rasterio as rio
from rasterio.merge import merge as rio_merge


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Constants
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

EXE_NAME = sys.argv[0].split('/')[-1]  # This script's filename

# Text printed when user calls this script without proper parameters
HELP_TEXT = f"Usage: {EXE_NAME}  TILES_DIR  OUT_DIR"

SRC_TIF_BASENAMES = (
    'gridmet20m_all',
    'gridmet20m_density',
    'gridmet20m_frst',
    'gridmet20m_frsthp',
    'gridmet20m_hp',
    'gridmet20m_strat_all',
    'gridmet20m_strat_frst',
)


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Functions
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def run_dill(fn: Callable, *args, **kwargs) -> Any:
    """Helper function to use dill instead of pickle for multiprocessing.

    This allows multiprocessing to accept lambda functions.
    """

    return dill.loads(fn)(*args, **kwargs)


def dispatch(
    jobs: iter,
    worker: Callable,
    max_workers=os.cpu_count(),  # Number of CPU cores available on machine
) -> Iterator[(Any, Any)]:
    """Run jobs in parallel.

    Parallel apply dispatching function: Run a list of jobs with a given
    worker function, in parallel, and yield worker results in order they
    finish.
    """

    worker = functools.partial(run_dill, dill.dumps(worker))  # Allow lambdas
    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        futures_jobs = {executor.submit(worker, j): j for j in jobs}
        for f in cf_as_completed(futures_jobs):
            yield (futures_jobs[f], f.result())


def get_tile_paths(dir_path: Path, set_name: str) -> Iterator[Path]:
    """List set of grid metric tiles/fragments.

    Get list of paths to raster fragments/tiles for a given set of grid
    metrics.
    """

    dir_path = Path(dir_path)
    for d in dir_path.iterdir():
        tif_path = d / f"{set_name}.tif"
        if tif_path.exists():
            yield tif_path


def mosaic_rasts(
    tif_paths: list[Path], band_name: str
) -> (np.ndarray, rio.transform.Affine):
    """Mosaic common layer for a given set of rasters tiles.

    Returns layer mosaic.
    """

    with TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)

        # Collect raster tiles/fragments pixel values
        counter = 0
        for path in tif_paths:
            # Get raster metadata
            with rio.open(path, mode='r') as src:
                layers = {
                    name: index
                    for index, name in enumerate(src.descriptions, start=1)
                }
                profile = dict(src.profile) | {
                    'count': 1,
                    'compress': 'lzw',
                }
                rast_arr = src.read(layers[band_name])

            # Extract band of interest from raster and store it in RAM/tmpdir
            tmp_rast_path = tmpdir / f"{counter}.tif"
            with rio.open(tmp_rast_path, mode='w', **profile) as tmp:
                tmp.write(rast_arr, indexes=1)

            counter += 1

        # Stitch raster fragments
        mosaic = rio_merge(list(tmpdir.glob("*.tif")))

    return mosaic


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def main() -> None:
    # Parse command line arguments
    max_workers = os.cpu_count()  # Number of CPU cores available on machine
    pos_args = []
    args = iter(sys.argv[1:])
    for a in args:
        if not a.startswith('-'):
            pos_args += [a] + list(args)
            break
        try:
            match a:
                case "--max-workers":
                    max_workers = int(next(args))
                case _:
                    print2("error: Invalid flag:", a)
                    sys.exit(1)
        except StopIteration:
            print2("error: Flag requires value:", a)
            sys.exit(1)
        except ValueError:
            print2("error: Invalid value for flag:", a)
            sys.exit(1)

    try:
        src_tiles_dir = Path(pos_args[0])
        out_dir = Path(pos_args[1])
    except IndexError:
        print2(HELP_TEXT)
        sys.exit(1)

    # Setup logging
    global log
    log = init_logger()

    # Print start time
    log.info("Starting...")

    # Ensure export directory exists
    out_dir.mkdir(exist_ok=True)

    # Stitch raster tiles/fragments together (one TIF mosaic for each grid
    # metric)
    for src_tif_basename in SRC_TIF_BASENAMES:
        log.info("Gathering fragments: %s", src_tif_basename)

        # Get raster tile/fragment paths
        src_tif_paths = list(get_tile_paths(src_tiles_dir, src_tif_basename))

        # Get metadata for first tile (and assume it is the same for the rest
        # of the tiles)
        with rio.open(src_tif_paths[0], mode='r') as f:
            crs = f.crs
            tif_layers = f.descriptions

        # Stitch rasters for the given layer (grid metric) and save mosaic
        log.info("Dispatching workers...")

        def worker(layer):
            rast_arr, affine = mosaic_rasts(src_tif_paths, layer)
            profile = {
                'driver': 'GTiff',
                'height': rast_arr.shape[1],
                'width': rast_arr.shape[2],
                'count': 1,
                'dtype': rast_arr.dtype,
                'crs': crs,
                'transform': affine,
                'compress': 'lzw'
            }
            mosaic_export_path = out_dir / f'{src_tif_basename}_{layer}.tif'
            with rio.open(mosaic_export_path, mode='w', **profile) as f:
                f.write(rast_arr)

        for job, _ in dispatch(tif_layers, worker, max_workers=max_workers):
            log.info("Worker finished: %s", job)

    # Print end time
    log.info("Finished")


if __name__ == '__main__':
    main()
