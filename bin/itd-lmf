#!/usr/bin/env Rscript
# Author: Daniel Rode


# Identify tree tops (TAO points) using local maxima filter.


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Import libraries
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# Import external libraries
library(sf, warn.conflicts = FALSE)
library(terra, warn.conflicts = FALSE)
library(lidR, warn.conflicts = FALSE)
library(rjson, warn.conflicts = FALSE)  # Required by lidR to read VPCs
library(lwgeom, warn.conflicts = FALSE)  # Required by sf::st_perimeter()

# Import shared code
source("/vogeler/lib/r/shared.r")

# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Constants
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# Text printed when user calls this script without proper parameters
HELP_TEXT = "Usage: itd-lmf [OPTIONS] LAS_PATH CHM_PATH WF_PATH OUT_DIR"


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# Warn that lidar is expected to already be height normalized
message("WARNING: This script expects points to already be height normalized")

# Parse command line arguments
clip_input = FALSE
clip_output = FALSE

pos_args = character()
args = commandArgs(trailingOnly = TRUE)
counter = 1
while (TRUE) {
    a = args[counter]
    if (is.na(a) || a == "--") {
        break
    } else if (!startsWith(a, "-")) {
        pos_args = c(pos_args, a)
    } else if (a == "--bounds-wkt") {
        clip_input = TRUE
        plot_wkt = args[counter + 1]
        counter = counter + 1
    } else if (a == "--buffer") {
        clip_output = TRUE
        plot_buffer = as.numeric(args[counter + 1])
        counter = counter + 1
    } else {
        stop("Invalid flag: ", a)
    }
    counter = counter + 1
}

if (length(pos_args) != 3) {
    cat(HELP_TEXT)
    quit(status = 1)
}
ctg_pth = pos_args[1]
chm_pth = pos_args[2]
wf_pth  = pos_args[3]
out_dir = pos_args[4]

cat("Args: ")
dput(args)

for (p in c(ctg_pth, chm_pth)) {
    if (! file.exists(p)) {
        stop("Path does not exist: ", p)
    }
}

# Ensure export directory exists
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

# Import/load lidar data
pdf(NULL)
ctg = lidR::readLAScatalog(
    ctg_pth,
    select=LIDAR_ATTR_FILTER,
    filter=LIDAR_POINT_FILTER,
    progress=FALSE  # Disable some lidR progress bars
)
if (clip_input) {
    plot_boundary = sf::st_as_sfc(plot_wkt) |> try(silent=TRUE)
    if (any(class(plot_boundary) == "try-error")) {
        stop("Invalid WKT: ", plot_wkt)
    }
    plot_boundary_plus_buff = plot_boundary
    if (clip_output) (
        plot_boundary_plus_buff = sf::st_buffer(plot_boundary, plot_buffer)
    )
    las = lidR::clip_roi(ctg, plot_boundary_plus_buff)
} else {
    plot_boundary = ctg$geometry
    plot_boundary_plus_buff = plot_boundary
    if (clip_output) (
        plot_boundary = sf::st_buffer(plot_boundary, -plot_buffer)
    )
    las = lidR::readLAS(ctg)
}
if (is.empty(las)) {
    message("Clip is empty")
    quit()
}

# Wrap boundary polygon into spatial dataframe object
plot_boundary = sf::st_as_sf(plot_boundary, crs=lidR::crs(ctg))
plot_boundary_plus_buff = sf::st_as_sf(
    plot_boundary_plus_buff, crs=lidR::crs(ctg)
)

# Discard low to the ground and below ground returns
las = lidR::filter_poi(las, Z >= HIGHPASS_DELIM)

# Discard high-in-the-sky returns
las = lidR::filter_poi(las, Z < LOWPASS_DELIM)

# If no points remain, quit
if (is.empty(las)) {
    message("No points remain after filtering")
    quit()
}

# Write point cloud plot clip to file
lidR::writeLAS(las, paste0(out_dir, "/plot.las"))

# Import/load CHM data
chm = terra::rast(chm_pth)
if (clip_input) {
    chm = terra::crop(chm, plot_boundary_plus_buff, mask=TRUE)
}

# Write plot CHM to file
terra::writeRaster(chm, paste0(out_dir, "/chm.tif"))

# Smooth canopy height model
smooth_chm = get_smooth_chm(chm)

# Import LMF window functions
source(wf_pth)

# Try different window functions
for (wf_name in names(wf_list)) {
    wf = wf_list[[wf_name]]

    # Locate tree tops (ITD) - CHM based using circular moving window
    ttops = lidR::locate_trees(chm, lidR::lmf(shape=c("circular"), ws=wf))

    # Write individual tree detection points to file
    sf::write_sf(
        sf::st_intersection(ttops, plot_boundary),
        paste0(out_dir, "/ttops_lmf_chm_", wf_name, ".fgb")
    )

    # Locate tree tops (ITD) - point cloud based using circular moving window
    ttops = lidR::locate_trees(las, lidR::lmf(shape=c("circular"), ws=wf))

    # Write individual tree detection points to file
    sf::write_sf(
        sf::st_intersection(ttops, plot_boundary),
        paste0(out_dir, "/ttops_lmf_las_", wf_name, ".fgb")
    )

    # Locate tree tops (ITD) - smoothed CHM based using circular moving window
    ttops = lidR::locate_trees(
        smooth_chm, lidR::lmf(shape=c("circular"), ws=wf)
    )

    # Write individual tree detection points to file
    sf::write_sf(
        sf::st_intersection(ttops, plot_boundary),
        paste0(out_dir, "/ttops_lmf_chmsmooth_", wf_name, ".fgb")
    )
}

# Inform that job completed
cat("DONE", "\n")
