#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Author: Daniel Rode


"""Regenerate portions of DTM where rock artifacts have been corrected."""


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Import libraries
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# Import standard libraries
import os
import sys
import hashlib
import traceback
from pathlib import Path
from logging import ERROR
from functools import partial

# Import external libraries
import pyogrio
import rasterio as rio
from pyproj.crs.crs import CRS
from rasterio.merge import merge
from shapely.geometry import box
from shapely.geometry import Polygon
from geopandas import GeoDataFrame

# Import in-house libraries
from vogeler.stdlib import init_logger
from vogeler.stdlib import print2
from vogeler.extlib import catgdf
from vogeler.stdlib import dispatch

# Import R libraries
from vogeler.r import rlib
from vogeler.r import rpy2_logger
from rpy2.robjects.vectors import IntVector
from rpy2.rinterface_lib.embedded import RRuntimeError

sf = rlib("sf")
lidr = rlib("lidR")
terra = rlib("terra")

rpy2_logger.setLevel(ERROR)  # Suppress R warning messages


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Constants
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

EXE_NAME = sys.argv[0].split('/')[-1]  # This script's filename

# Text printed when user calls this script without proper parameters
HELP_TEXT = f"""Usage: {EXE_NAME} [OPTION]...  DTM_DIR  DTM_TILES_SHP_PATH
  LAS_PATH  ROCKS_SHP_PATH  OUT_DIR"""

# Number of CPU cores available on machine
MAX_WORKERS = os.cpu_count()

# Point cloud import filters
CUSTOM_LIDAR_CODE_ROCK = 102
LIDAR_POINT_FILTER = (
    f"-keep_extended_class 0 1 2 3 4 5 9 {CUSTOM_LIDAR_CODE_ROCK} "
    "-drop_withheld"
)
LIDAR_ATTR_FILTER = "xyzirnc"  # See https://rdrr.io/cran/lidR/man/readLAS.html

# Amount to buffer polygons (to avoid DTM edge artifacts)
POLY_BUFF = 20

# Resolution to make new DTM raster patches
DTM_RES = 0.25

# This number is the classification for LiDAR points that represent rock
# artifacts
CUSTOM_LIDAR_CODE_ROCK = 102

# Patch/plot bounding box perimeter length threshold for subdividing plots
# (this chunks up large plots so they are processed in pieces so the workflow
# does not crash)
DICE_THRESH = 2800

# Side length of grid-cells used to dice up large plots
DICE_SIZE = 1000


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Functions
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def dice(poly: Polygon, crs: CRS, tile_length: int) -> GeoDataFrame:
    """Dice up a polygon into a grid of polygon tiles."""

    # Align grid so that its cell coordinates are divisible by cell length
    minx, miny, maxx, maxy = poly.bounds
    grid_minx = minx // tile_length * tile_length
    grid_miny = miny // tile_length * tile_length
    grid_maxx = (maxx // tile_length * tile_length) + tile_length
    grid_maxy = (maxy // tile_length * tile_length) + tile_length

    # Define generator to create grid cells as polygons
    def gen_tiles(minx, miny, maxx, maxy, length):
        x = minx
        while x < maxx:
            y = miny
            while y < maxy:
                tile = box(
                    minx=x,
                    maxx=x + length,
                    miny=y,
                    maxy=y + length,
                ).intersection(poly)
                y += length

                if not tile.is_empty:
                    yield tile

            x += length

    # Collect grid cell polygons into GeoDataFrame
    diced_poly = GeoDataFrame(
        geometry=list(gen_tiles(
            minx=grid_minx,
            miny=grid_miny,
            maxx=grid_maxx,
            maxy=grid_maxy,
            length=tile_length,
        )),
        crs=crs,
    )

    return diced_poly


def hash_wkt(wkt: str) -> str:
    """Take a given WKT string and return its SHA1 hash."""

    return hashlib.sha1(bytes(str(wkt), 'utf8')).hexdigest()


def get_aoi(rocks_shp_path: Path) -> GeoDataFrame:
    """Get dataframe of buffered rocks."""

    # Import rock polygons
    aoi = pyogrio.read_dataframe(rocks_shp_path)

    # Subdivide large polygons so they get processed in pieces
    b = aoi.geometry.bounds
    aoi['bbox_perimeter'] = b.maxx - b.minx + b.maxy - b.miny  # Technically,
        # this is only half of the bounding box perimeter. That doesn't matter
        # though, since the same equation is used for all polygons, and
        # DICE_THRESH was adjusted accordingly.
    aoi_small = aoi[aoi['bbox_perimeter'] <= DICE_THRESH]
    aoi_big = aoi[aoi['bbox_perimeter'] > DICE_THRESH]
    aoi = catgdf([
        dice(poly=p, crs=aoi.crs, tile_length=DICE_SIZE)
        for p in aoi_big.geometry.iloc
    ] + [aoi_small])

    # Label/fingerprint each polygon with its SHA1 hash (as ID column)
    aoi['id'] = aoi['geometry'].apply(hash_wkt)

    # Buffer polygons (to avoid edge effects in later processing)
    aoi['geometry'] = aoi.buffer(POLY_BUFF)

    cols = ['geometry', 'id']
    return aoi[cols]


def get_tiles2fix(
    aoi: GeoDataFrame, tiles_shp_path: Path, dtm_dir: Path,
) -> list[Path]:
    """List DTM tiles that intersect AOI.

    Find which DTM tiles intersect with the given boundary polygon (aoi),
    then return tiles as list of paths.
    """

    # Import boundaries for BH Block 1 and Block 2 LiDAR tiles
    tiles = pyogrio.read_dataframe(tiles_shp_path).to_crs(aoi.crs)

    # Make list of Block 1 tiles that intersect with aoi
    hot_tiles = list(
        tiles
        .sjoin(aoi, how='inner', predicate='intersects')
        ['TILENAME'].str.lower()
    )
    tile_paths = {
        # Convert the tile ID part of the path to lowercase so that tile ID to
        # path matching will be case-insensitive
        p.name.split("_")[0].lower(): p
        for p in Path(dtm_dir).glob("*.tif", case_sensitive=False)
    }
    path_list = [Path(tile_paths[p]) for p in hot_tiles]

    # Remove duplicates
    path_list = list(set(path_list))

    return path_list


def gen_dtm_patch(
    poly: GeoDataFrame, out_dir: Path, ctg_path: Path,
) -> None | str:
    """Generate new DTM patch for given polygon."""

    out_dir = Path(out_dir)
    poly_id = poly.iloc[0]['id']
    try:
        poly_bounds_path = f"{out_dir / poly_id}.fgb"
        poly.to_file(poly_bounds_path)

        # Import lidar collection
        ctg = lidr.readLAScatalog(
            str(ctg_path),
            progress=False,
            select=LIDAR_ATTR_FILTER,
            filter=LIDAR_POINT_FILTER,
        )

        # Get polygon of where new DTM needs generated
        poly = sf.read_sf(str(poly_bounds_path))
        poly = sf.st_zm(poly, drop=True, what="ZM")  # Drop poly's Z dimension

        # Import lidar points
        las = lidr.clip_roi(ctg, poly)

        # Generate new DTM raster patch
        try:
            dtm_patch = lidr.rasterize_terrain(
                las,
                res=DTM_RES,
                algorithm=lidr.tin(),
                use_class=IntVector([2, 9, CUSTOM_LIDAR_CODE_ROCK]),
            )
        except RRuntimeError as e:
            err_msg = (
                "Error: No ground points found. Impossible to compute a DTM.\n"
            )
            if str(e) == err_msg:
                return "No ground points"

            raise e

        # Shave buffer off DTM patch
        dtm_patch = terra.crop(
            dtm_patch,
            sf.st_buffer(poly, -POLY_BUFF),
            mask=True,
        )

        # Save DTM patch to raster file
        tmp_out_path = out_dir / f".tmp.{poly_id}.tif"
        terra.writeRaster(
            dtm_patch, str(tmp_out_path), filetype="GTiff", overwrite=False
        )
        out_path = Path(f"{out_dir / poly_id}.tif")
        tmp_out_path.rename(out_path)
    except Exception as e:
        traceback.print_exc()
        return str(e)

    return None


def gen_all_dtm_patches(
    aoi: GeoDataFrame, las_ctg_path: Path, out_dir: Path,
) -> None:
    """Generate DTM patch for each buffered rock polygon."""

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    def get_jobs(aoi, out_dir):
        for i in aoi.iloc:
            # Check if job was already done
            out_path = Path(f"{out_dir / i['id']}.tif")
            if out_path.exists():
                log.info("Already exists (skipping): %s", out_path)
            else:
                yield GeoDataFrame([i], crs=aoi.crs)

    fn = partial(
        gen_dtm_patch,
        out_dir=out_dir,
        ctg_path=las_ctg_path,
    )
    jobs = get_jobs(aoi, out_dir)
    for job, result in dispatch(jobs=jobs, worker=fn):
        if result is None:
            log.info("Job finished: %s", hash_wkt(job))
        elif result == "No ground points":
            log.info("Job finished (no ground points): %s", hash_wkt(job))
        else:
            log.info("Job failed: %s: %s", hash_wkt(job), result)


def patch_dtm_tile(
    tile_path: Path, aoi: GeoDataFrame, patch_dir: Path, out_dir: Path,
) -> None | str:
    """Patch DTM tile.

    Patch a given DTM raster tile by overlaying intersecting DTM raster
    patches, flattening the stack, then cropping it all to the original
    tile extent.
    """

    tile_path = Path(tile_path)
    out_dir = Path(out_dir)

    try:
        # Import vendor DTM tile metadata
        with rio.open(tile_path) as f:
            tile_crs = f.crs
            tile_bounds = f.bounds
            tile_height, tile_width = f.shape

        # Get paths of DTM patches that intersect with the given DTM tile
        patch_paths = [
            Path(patch_dir, f"{patch_id}.tif")
            for patch_id in aoi[aoi.intersects(box(*tile_bounds))]['id']
        ]

        # Drop ghost paths (to patches that weren't generated--likely due to
        # lack of available ground points)
        patch_paths = filter(lambda x: x.exists(), patch_paths)

        # Patch DTM tile by overlaying patches on top and flattening the stack
        rast_pieces = [*patch_paths, tile_path]
        arr, affine = merge(rast_pieces, bounds=tile_bounds)
        arr = arr[0]

        # Save patched DTM tile
        out_path = out_dir / tile_path.name
        profile = {
            'driver': 'GTiff',
            'width': tile_width,
            'height': tile_height,
            'count': 1,
            'dtype': arr.dtype,
            'crs': tile_crs,
            'transform': affine,
            'compress': 'lzw',
        }
        with rio.open(out_path, 'w', **profile) as f:
            f.write(arr, 1)
    except Exception as e:
        traceback.print_exc()
        return str(e)

    return None


def patch_all_dtm_tiles(
    tile_paths: list[Path],
    aoi: GeoDataFrame,
    patch_dir: Path,
    out_dir: Path,
):
    """Run function patch_dtm_tile on all raster tiles, in parallel."""

    out_dir = Path(out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    def get_jobs(tile_paths, out_dir):
        for p in tile_paths:
            # Check if job was already done
            out_path = Path(f"{out_dir / p.name}")
            if out_path.exists():
                log.info("Already exists (skipping): %s", out_path)
            else:
                yield p

    fn = partial(
        patch_dtm_tile,
        aoi=aoi,
        patch_dir=patch_dir,
        out_dir=out_dir,
    )
    jobs = get_jobs(tile_paths, out_dir)
    for job, result in dispatch(jobs, fn):
        if result is None:
            log.info("Job finished: %s", hash_wkt(job))
        else:
            log.info("Job failed: %s: %s", hash_wkt(job), result)


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

def main():
    # Parse command line arguments
    pos_args = []
    args = iter(sys.argv[1:])
    for a in args:
        if (not a.startswith('-')) or (a == '--'):
            pos_args += [a] + list(args)
            break
        try:
            match a:
                case '-j' | '--max-workers':
                    global MAX_WORKERS
                    MAX_WORKERS = int(next(args))
                case _:
                    print2("error: Invalid flag", a)
                    sys.exit(1)
        except StopIteration:
            print2("error: Flag requires value:", a)
            sys.exit(1)
        except ValueError:
            print2("error: Invalid value for flag:", a)
            sys.exit(1)

    try:
        dtm_dir = Path(pos_args[0])
        tiles_shp_path = Path(pos_args[1])
        las_ctg_path = Path(pos_args[2])
        rocks_shp_path = Path(pos_args[3])
        out_dir = Path(pos_args[4])
    except IndexError:
        print2(HELP_TEXT)
        sys.exit(1)

    for p in (
        rocks_shp_path,
        tiles_shp_path,
        dtm_dir,
        las_ctg_path,
    ):
        if not p.exists():
            print2("error: Path does not exist:", p)
            sys.exit(1)

    # Setup logging
    global log
    log = init_logger()

    log.warning(
        "This script expects all provided geospatial files to all have the "
        "same CRS."
    )

    # Get polygon collection of rock areas that need to be fixed
    log.info("Finding areas that need fixed...")
    aoi = get_aoi(rocks_shp_path)

    # Get list of paths to vendor DTM tiles that intersect with AOI polygons
    log.info("Finding vendor DTM tiles that need patched...")
    tiles2fix = get_tiles2fix(aoi, tiles_shp_path, dtm_dir)

    # Generate DTM raster patches
    log.info("Generating DTM patches in parallel...")
    gen_all_dtm_patches(aoi, las_ctg_path, out_dir / "patches/")
    log.info("All workers finished")

    # Apply patches to vendor DTM raster tiles
    log.info("Applying DTM patches in parallel...")
    patch_all_dtm_tiles(
        tile_paths=tiles2fix,
        aoi=aoi,
        patch_dir=out_dir / "patches/",
        out_dir=out_dir / "patched_tiles/",
    )
    log.info("All workers finished")


if __name__ == '__main__':
    main()
